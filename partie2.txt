Certainly! Below is the text extracted from Partie 2 of the provided document. This text version should help you work with the content as needed.

---

**Partie 2 – Gestion basique des tables**

**Maintenant que vous pouvez interagir avec un fichier binaire pour y encoder ou lire ce que vous voulez, il est temps de s'attaquer à la DB et à son formatage. Une DB doit avoir un nom et peut avoir un nombre arbitraire de tables (potentiellement aucune). Nous représenterons cela par le fait que la DB de nom <db> est représentée par un dossier du même nom. Dans ce dossier, chaque table sera représentée dans son propre fichier. Dès lors la table <table> dans la DB <db> sera encodée dans le fichier <db>/<table>.table (remarquez l’extension .table permettant d'identifier les différentes tables). Tout fichier ayant une extension différente de .table est simplement ignoré par la base de données.**

Chaque fichier de table est découpé en trois parties ordonnées : 
1. **le header (également appelé en-tête);**
2. **le string buffer (également appelé mémoire de chaînes de caractères);**
3. **l’entry buffer (également appelé mémoire des entrées).**

---

**2.1 Le header**

Le header contient les informations générales relatives à la table en question. Plus précisément, il est structuré comme ceci :
1. Constante magique "ULDB" (4 bytes);
2. Nombre de champs (4 bytes);
3. Signature de la table (taille variable);
4. Offset du string buffer (4 bytes);
5. Première place disponible dans le string buffer (4 bytes);
6. Offset de la première entrée (4 bytes);

La plupart des formats de fichiers binaires utilisent un système de constante magique permettant de les reconnaître. C’est grâce à cela qu’un lecteur de PDF (tel que Evince) pourra afficher cet énoncé, même si vous changez son extension.

La signature de la table est encodée comme ceci : pour chaque champ, son type est encodé comme un entier sur 1 byte (1 pour un entier et 2 pour une chaîne de caractères) et ensuite son nom est encodé comme un string, c'est-à-dire d'abord un entier n sur 2 bytes représentant sa longueur et ensuite une suite de n bytes avec son encodage UTF-8 (cf. la section Gestion de fichiers binaires).

**Exemple :**  
Considérons une table en version 1 avec la signature suivante :
1. MNEMONIQUE (entier);
2. NOM (string);
3. COORDINATEUR (string);
4. CREDITS (entier).

| Offset | Bytes | Description |
| --- | --- | --- |
| 00 | 55 4c 44 42 | ULDB |
| 04 | 04 00 00 00 | 4 champs |
| 08 | 01 | INTEGER |
| 09 | 0a 00 | String sur 0x000a = 10 bytes |
| 0b | 4d 4e 45 4d 4f 4e 49 51 55 45 | 'MNEMONIQUE' |
| 15 | 02 | STRING |
| 16 | 03 00 | String sur 0x0003 = 3 bytes |
| 18 | 4e 4f 4d | 'NOM' |
| 1b | 02 | STRING |
| 1c | 0c 00 | String sur 0x000c = 12 bytes |
| 1e | 43 4f 4f 52 44 49 4e 41 54 45 55 52 | 'COORDINATEUR' |
| 2a | 01 | INTEGER |
| 2b | 07 00 | String sur 0x0007 = 7 bytes |
| 2d | 43 52 45 44 49 54 53 | 'CREDITS' |
| 34 | 40 00 00 00 | Pointeur vers string buffer |
| 38 | 40 00 00 00 | 1ère place disponible |
| 3c | 50 00 00 00 | Pointeur vers entry buffer |
| 40 | 00 00 00 00... 00 00 00 00 | String buffer (16 bytes) |

De manière équivalente, si cette table s'appelle cours et fait partie de la DB programme, alors le contenu du fichier programme/cours.table peut être affiché avec hexdump et donne :

```
$ hexdump -C -n 80 programme/cours.table
00000000  55 4c 44 42 04 00 00 00  01 0a 00 4d 4e 45 4d 4f  |ULDB.......MNEMO|
00000010  4e 49 51 55 45 02 03 00  4e 4f 4d 02 0c 00 43 4f  |NIQUE...NOM...CO|
00000020  4f 52 44 49 4e 41 54 45  55 52 01 07 00 43 52 45  |ORDINATEUR...CRE|
00000030  44 49 54 53 40 00 00 00  40 00 00 00 50 00 00 00  |DITS@...@...P...|
00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000050
```

---

**2.2 Le string buffer**

Le string buffer est la région du fichier dans laquelle toutes les chaînes de caractères vont devoir être écrites. Leur format est le même que celui décrit dans la phase Gestion de fichiers binaires : un entier n sur 2 bytes suivi de n bytes correspondant à l'encodage UTF-8 du string.

La taille de ce buffer doit obligatoirement être une puissance de 2, et vaut 16 à l'initialisation. Dès qu'une nouvelle chaîne de caractères doit être encodée, elle doit être écrite dans ce buffer. Si le buffer ne contient pas assez de place, alors il faut l'agrandir et donc réécrire le fichier associé à la table. Lorsque ce buffer est agrandi, il faut garantir que sa taille reste bien une puissance de 2 mais qu'il soit suffisamment grand pour pouvoir contenir la nouvelle chaîne de caractères.

Par exemple, après avoir inséré les entrées :
- MNEMONIQUE = 101
- NOM = "Programmation"
- COORDINATEUR = "Thierry Massart"
- CREDITS = 10

et
- MNEMONIQUE = 102
- NOM = "Fonctionnement des ordinateurs"
- COORDINATEUR = "Gilles Geeraerts"
- CREDITS = 5

le string buffer aura une taille de 128 bytes et sera donné par :

```
$ hexdump -C -s 64 -n 128 programme/cours.table
00000040  0d 00 50 72 6f 67 72 61  6d 6d 61 74 69 6f 6e 0f  |..Programmation.|
00000050  00 54 68 69 65 72 72 79  20 4d 61 73 73 61 72 74  |.Thierry Massart|
00000060  1e 00 46 6f 6e 63 74 69  6f 6e 6e 65 6d 65 6e 74  |..Fonctionnement|
00000070  20 64 65 73 20 6f 72 64  69 6e 61 74 65 75 72 73  | des ordinateurs|
00000080  10 00 47 69 6c 6c 65 73  20 47 65 65 72 61 65 72  |..Gilles Geeraer|
00000090  74 73 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |ts..............|
000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
* 000000c0
```

De plus, le header aura également été modifié puisque la première place disponible dans le string buffer est maintenant 0x00000092 et l'entry buffer commence à la position 0x000000c0.

---

**2.3 L’entry buffer**

L’entry buffer est la région du fichier dans laquelle toutes les entrées doivent être encodées. Cette région commence également par un mini-header et contient ensuite une liste doublement chaînée des entrées.

Ce mini-header sur 20 bytes contient :
1. Le dernier ID utilisé (0 si aucune insertion n’a été réalisée) (4 bytes);
2. Le nombre d’entrées présentes dans cette table (4 bytes);
3. Un pointeur vers la première entrée (4 bytes);
4. Un pointeur vers la dernière entrée (4 bytes);
5. Un pointeur sur 4 bytes réservé (il servira lors de la phase Modification et suppression des entrées).

Si l’entry buffer est vide, alors ces trois pointeurs doivent valoir -1 (donc ff ff ff ff).

En particulier, à la création de la table, ce header est :

```
00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff
```

Ensuite, la liste chaînée contient des éléments formatés comme suit :
1. L’identifiant (unique) de l’entrée (4 bytes);
2. Les champs de l’entrée dans l’ordre de la signature donc :
   - Si le ième champ est un entier, cet entier est encodé sur 4 bytes;
   - Si le ième champ est un string, alors il y a un pointeur sur 4 bytes vers le string dans le string buffer;
3. Un pointeur vers l’élément précédent (4 bytes);
4. Un pointeur vers l’élément suivant (4 bytes).

Notez que s’il n’y a aucune entrée dans la table, alors le pointeur dans le header doit être à -1 (i.e. 0xFFFFFFFF). De la même manière, le pointeur précédent du premier élément de la liste chaînée doit valoir -1 et le pointeur suivant du dernier élément doit également valoir -1.

---

Let me know if you need further clarification or additional sections!